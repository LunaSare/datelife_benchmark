new1.gfr <- get_datelife_result(new1, bold=TRUE)
library(datelife)
library(ape)
library(pastis)
new1.gfr <- get_datelife_result(new1, bold=TRUE)
taxa.tree <- which.max(sapply(new1.gfr, nrow)) # this will show the first option that matches the logical
taxa.tree
new1.sr_ct <- SummarizeResults(new1.gfr[taxa.tree], output.format = "phylo.all")
new1.sr_ct
new1.sr_ct <- new1.sr_ct[[1]] # importante!!! desenlistar el arbol phylo
clades <- repeat("0", length(new1.sr_ct$tip.label))
n <- 0
for (taxon in new1.sr_ct$tip.label) {#
	n <- n+1#
	if(any(grepl(taxon, missing.taxa.listing))){#
		x <- phytools::getParent(new1.sr_ct, n)#
		print(x)#
	}#
}
filtered.results <- new1.gfr
prop <- c()#
		missing.taxa.listing <- c()#
		for (taxon in rownames(filtered.results[[1]])){#
			prop <- c(prop, paste(length(which(taxon==x)), "/", length(filtered.results), sep=""))#
			if(length(which(taxon==x))<length(filtered.results)) {#
			missing.taxa.listing <- c(missing.taxa.listing, taxon)			#
			}#
		}#
		missing.taxa.summary <- data.frame(Taxon=rownames(filtered.results[[1]]), Chronograms=prop)
missing.taxa.listing
clades
clades <- repeat("0", length(new1.sr_ct$tip.label))#
n <- 0#
for (taxon in new1.sr_ct$tip.label) {#
	n <- n+1#
	if(any(grepl(taxon, missing.taxa.listing))){#
		x <- phytools::getParent(new1.sr_ct, n)#
		print(x)#
	}#
}
plot(new1.sr_ct)
nodelabels()
tiplabels(1:9)
ape::axisPhylo()
max(ape::branching.times(new1.sr_ct))
new1.sr_ct$tip.label[1]
new1.df_ct
new1.df_ct <- data.frame(taxon = new1.sr_8[[1]]$tip.label, clade= c("2", "2", "3","3","4","4","4", "5", "6"))
new1.df_ct
new1.df_ct <- data.frame(taxon = new1.sr_ct[[1]]$tip.label, clade= c("2", "2", "3","3","4","4","4", "5", "6"))
new1.df_ct <- data.frame(taxon = new1.sr_ct[1]$tip.label, clade= c("2", "2", "3","3","4","4","4", "5", "6"))
new1.df_ct <- data.frame(taxon = new1.sr_ct$tip.label, clade= c("2", "2", "3","3","4","4","4", "5", "6"))
new1.df_ct
new1.sr_ct
taxa_names <- gsub(pattern = " ", replacement = "_", x = new1.sr_ct[[1]]$tip.label)#
new1.df_ct <- data.frame(taxon = taxa_names, clade= c(rep("2", 7),"3","4"))#
new1.sr_ct$tip.label <- taxa_names#
new1.ri  <- read_input(constraint_tree = new1.sr_ct, taxa_list = new1.df_ct, missing_clades = NA, sequences = NA, output_template = NA)
new1.ri
sequence(length(taxa_names))
taxa_names <- gsub(pattern = " ", replacement = "_", x = new1.sr_ct[[1]]$tip.label)
taxa.tree
new1.sr <- SummarizeResults(new1.gfr[taxa.tree], output.format = "phylo.all")
new1.sr <- new1.sr[[1]]
new1.sr
taxa_names <- gsub(pattern = " ", replacement = "_", x = new1.sr$tip.label)
sequence(length(taxa_names))
new1.df <- data.frame(taxon = taxa_names, clade= sequence(length(taxa_names)))
new1.ri  <- read_input(constraint_tree = new1.sr, taxa_list = new1.df, missing_clades = NA, sequences = NA, output_template = NA)
taxa_names
new1.df
new1.sr_ct
new1.df_ct
new1.df <- data.frame(taxon = new1.sr$tip.label, clade= sequence(length(taxa_names)))
new1.ri  <- read_input(constraint_tree = new1.sr, taxa_list = new1.df, missing_clades = NA, sequences = NA, output_template = NA)
new1.ri
pastis_simple(pastisData = new1.ri, base_name = "jungle2")
getwd()
file <- "/Users/luna/Google Drive/datelife/jungle2.nexus"
system(paste("mb > execute ", file))
"mb > execute ", file
paste("mb > execute ", file)
new1.sr$tip.label <- gsub(pattern = " ", replacement = "_", x = new1.sr$tip.label)
new1.df <- data.frame(taxon = new1.sr$tip.label, clade= sequence(length(taxa_names)))
new1.sr$tip.label
new1.df <- data.frame(taxon = new1.sr$tip.label, clade= sequence(length(taxa_names)))
new1.ri  <- read_input(constraint_tree = new1.sr, taxa_list = new1.df, missing_clades = NA, sequences = NA, output_template = NA)
setwd("/Users/luna/")
getwd()
file <- "jungle2.nexus"
system(paste("mb > execute", file))
ips::mrbayes
pastis_simple(pastisData = new1.ri, base_name = "jungle2")
install.packages("paleotree")
paleotree::createMrBayesConstraints(tree= new1.sr, partial=FALSE)
so, just need to paste stuff
pastis::pastis_simple
c(#
#
	    "\nbegin mrbayes;",#
#
	    paste("\tlset nst=", nst, " rates=", 		#
#
	        rates, " ngammacat=", ngammacat, ";", sep = ""),#
#
        paste("\tmcmc nruns=", nruns, " ngen=", 		#
#
	        as.integer(ngen), " printfreq=", printfreq, 		#
#
	        " samplefreq=", samplefreq, " nchains=", 		#
#
	        nchains, " savebrlens=", savebrlens, 			#
#
	        " temp=", temp, ";", sep = ""),#
#
	    paste("\tsumt filename=", file, " burnin=", 		#
#
	        burnin, " contype=", contype, ";", sep = ""),#
#
	    "end;"#
#
	)
x <- read.nexus("~/jungle2.nexus.t")
for (i in seq(1, 50001, 5000)){#
	plot(x[[i]])#
	axisPhylo()#
	nodelabels()#
}
ct <- paleotree::createMrBayesConstraints(tree= new1.sr, partial=FALSE) # this works perfectly:
paste(ct, collapse=TRUE)
paste0(ct, collapse=TRUE)
paste0(ct, collapse="")
paste0(ct, collapse="\n")
paste(ct, collapse="\n")
paste(ct, "\n", collapse="")
paste(ct, collapse="\n")
ct
ct.txt <- paste(ct, collapse="\n")
write(ct.txt, file="jungle_constraints.txt")
x <- read.nexus("~/jungle3.nexus.t")#
for (i in seq(1, 50001, 5000)){#
	plot(x[[i]])#
	axisPhylo()#
	nodelabels()#
}
for (j in 1:7){#
	file <- paste("~/jungle3", "_node", j, ".nexus.t", sep="")#
	print(file)#
	x <- read.nexus(file)#
	for (i in seq(1, 50001, 5000)){#
		pdf(file=paste(file, "_", i,".pdf", sep=""))#
		plot(x[[i]])#
		axisPhylo()#
		nodelabels()#
		dev.off()#
	}#
}
library(datelife)#
library(ape)#
library(geiger)#
library(pastis)
#' Takes a constraint tree and uses mrBayes to get node ages and branch lengths given a set of node calibrations#
#' @param phy The constraint tree: a phylo object or a newick character string, with or without branch lengths.#
#' @param ncalibration The node calibrations: a phylo object with branch lengths proportional to time; all nodes in ncalibration will be used as calibrations. In the future, it will also take a list with two elements: the first is a list of character vectors with the names of taxa constituting each calibration node; the second is a numeric vector with the ages to use as calibrations for each node.#
#' @param file A character vector specifying the name of mrBayes run file and outputs (can specify directory too).#
#' @return A phylo tree with branch lengths proportional to time. It will save all mrBayes outputs in the working directory.#
#' @export#
GetMrBayesTree <- function(phy=NULL, ncalibration=NULL, file="mrbayes_run.nexus"){#
	runfile <- MakeMrBayesRunFile(phy= phy, ncalibration= ncalibration, file=file)#
	new.tree <- MrBayesRun(file=runfile)#
	return(new.tree)#
}#
#
#' Makes a mrBayes run block file with a constraint topology and a set of node calibrations#
#' @inheritParams GetMrBayesTree#
#' @return A MrBayes block run file in nexus format.#
#' @export#
MakeMrBayesRunFile <- function(phy= NULL, ncalibration= NULL, file="mrbayes_run.nexus"){#
    if (!inherits(phy, "phylo")) {#
        phy <- ProcessPhy(input=phy, verbose=FALSE)#
    }#
    phy <- ConvertSpacesToUnderscores(phy)#
	constraints <- paleotree::createMrBayesConstraints(tree= phy, partial=FALSE) # this works perfectly#
	calibrations <- GetMrBayesNodeCalibrations(phy=phy, ncalibration=ncalibration, ncalibrationType = "fixed")#
	og <- IdentifySingletonOutgroup(phy)#
	if(!is.na(og)) ogroup <- paste0("outgroup ", og, ";")#
#
	bayes_data <- c(paste("   Begin DATA; \nDimensions ntax=", length(phy$tip.label), "nchar=1;"),#
	"Format datatype=DNA gap=- missing=?;",#
	"Matrix\n",#
	paste(phy$tip.label, "?"),#
	";")#
#
    bayes_set <- c("   Begin MRBAYES;",#
    	"unlink shape=(all) tratio=(all) statefreq=(all) revmat=(all) pinvar=(all);\n",#
    	constraints[-length(constraints)],#
    	ogroup, "",#
    	constraints[length(constraints)], "",#
    	"prset nodeagepr=calibrated;", "",#
    	calibrations, "\n",#
    	"   set usebeagle=no Beaglesse=no;", "",#
    	paste("prset ", c("brlenspr=clock:birthdeath", "Extinctionpr = Fixed(0)",#
    	"Speciationpr=exponential(1)", "clockvarpr=ibr", "ibrvarpr=exponential(10)"), ";", sep=""),#
    	"mcmcp nruns=1 nchains=1 ngen=50000000 samplefreq=1000;",#
    	"mcmc;", "",#
    	paste0("sumt filename=", file, " burnin=5000000 contype=halfcompat;\n"),#
    	"end;"#
    	)#
#
	all <- c(bayes_data, "\n", bayes_set)#
	write(all, file)#
}#
#
#' Runs MrBayes from R.#
#' @inheritParams GetMrBayesTree#
#' @return MrBayes outputs.#
MrBayesRun <- function(file=NULL){#
	# code borrowed from phyloch::mrbayes()#
	if(is.null(file)) stop("You must provide a block file for MrBayes run")#
	if (.Platform$OS.type == "unix"){#
		system(paste("mb > execute", file))#
	} else {#
		system(paste("mrbayes ", file, ".bayes", sep = ""))#
	}#
	tr <- ape::read.nexus(paste(file, ".con.tre", sep = ""))#
	return(tr)#
}#
#
#' Writes the node calibrations block for a MrBayes run file.#
#' @inheritParams GetMrBayesTree#
#' @param ncalibrationType A character string specifying the type of calibration. Only "fixed" implementd for now.#
#' @return A set of MrBayes calibration commands printed in console as character strings or as a text file with name specified in file.#
#' @export#
# This function is set to match node names with constraints obtained from paleotree::GetMrBayesConstraints#
GetMrBayesNodeCalibrations <- function(phy=NULL, ncalibration=NULL, ncalibrationType = "fixed", file = NULL){#
#
    if (!inherits(phy, "phylo")) {#
        phy <- ProcessPhy(input=phy, verbose=FALSE)#
    }#
    if (!inherits(ncalibration, "phylo")) {#
       ncalibration <- ProcessPhy(input=ncalibration, verbose=FALSE)#
    }#
        # if(!is.list(ncalibration))stop("ncalibration must be a tree or a list with taxon names and dates")#
    if(is.null(ncalibration$edge.length) | !ape::is.ultrametric(ncalibration))#
    	stop("ncalibration tree must have branch lengths and be ultrametric.")#
    phy <- ConvertSpacesToUnderscores(phy)#
    ncalibration <- ConvertSpacesToUnderscores(ncalibration)#
    splits.ncalibration <- ape::prop.part(ncalibration)#
    includes.ncalibration <- lapply(splits.ncalibration, function(x) ncalibration$tip.label[x])#
	nodes <- sapply(includes.ncalibration, function(tax)#
				phytools::findMRCA(phy, tax, type="node")) - length(phy$tip.label)#
	root <- which(nodes==1) # tests for the presence of a root calibration, which should be implemented with treeagepr and not with calibrate#
	if(length(root)!=0){#
		nodes <- nodes[-root]#
		ncalibration <- ape::branching.times(ncalibration)[-root]#
	}#
	calibrations <- paste0("calibrate node", nodes-1, " = ", ncalibrationType, "(", ncalibration, ");")#
	if(length(root)!=0){#
		calibrations <- c(calibrations, paste0("prset treeagepr = ", ncalibrationType, "(",#
		ape::branching.times(ncalibration)[root], ");"))#
	}#
    if (!is.null(file)) {#
        write(calibrations, file)#
    }#
    else {#
        return(calibrations)#
    }#
}#
#
#' Identifies the presence of a single lineage outgroup in a phylogeny.#
#' @inheritParams GetMrBayesTree#
#' @return A character vector with the name of the single lineage outgroup. Returns NA if there is none.#
#' @export#
IdentifySingletonOutgroup <- function(phy=NULL){#
    if (!inherits(phy, "phylo")) {#
        phy <- ProcessPhy(input=phy, verbose=FALSE)#
    }#
	phy <- ConvertSpacesToUnderscores(phy)#
    outgroup <- NA#
    splits <- ape::prop.part(phy)#
    if(length(splits)>1){#
    	index <- which.max(sapply(splits, length))#
    	s1 <- splits[[index]]#
    	index2 <- which.max(sapply(splits[-index], length))#
    	s2 <- splits[-index][[index2]]#
    	if(length(s1)-length(s2) == 1){#
    		outgroup <- phy$tip.label[s1[!(s1 %in% s2)]]#
    	}#
    }#
    return(outgroup)#
}
jun.ed <- EstimateDates(jun, bold=TRUE)
jun <- "((((Homo sapiens,Macaca mulatta)Catarrhini,((Melursus ursinus,Canis lupus pallipes)Caniformia,((Panthera pardus,Panthera tigris)Panthera,Herpestes fuscus))Carnivora)Boreoeutheria,Elephas maximus)Eutheria,Haliastur indus)Amniota;"
jun.ed <- EstimateDates(jun, bold=TRUE)
lapply(jun.ed, "[", "tip.label")
.Platform$OS.type == "unix"
file <- "~/Google Drive/datelife/mrbayes_tests/jungle_book_spp_tests/jungle1_modified.nexus"
system(paste("mb > execute", file))
?system
MrBayesRun <- function(file=NULL){#
	# code borrowed from phyloch::mrbayes()#
	if(is.null(file)) stop("You must provide a block file for MrBayes run")#
	if (.Platform$OS.type == "unix"){#
		system(paste("mb > execute", file))#
	} else {#
		system(paste("mrbayes ", file, ".bayes", sep = ""))#
	}#
	tr <- read.nexus(paste(filed, ".con.tre", sep = ""))#
	return(tr)#
}
a <- MrBayesRun(file)
MrBayesRun <- function(file=NULL){#
	# code borrowed from phyloch::mrbayes()#
	if(is.null(file)) stop("You must provide a block file for MrBayes run")#
	if (.Platform$OS.type == "unix"){#
		system(paste("mb > execute", file))#
	} else {#
		system(paste("mrbayes ", file, ".bayes", sep = ""))#
	}#
	tr <- read.nexus(paste(file, ".con.tre", sep = ""))#
	return(tr)#
}
a <- MrBayesRun(file)
a
system("echo PATH")
system("echo $PATH")
asd <- "((Zea mays,Oryza sativa),((Arabidopsis thaliana,(Glycine max,Medicago sativa)),Solanum lycopersicum)Pentapetalae);"
pla <- make_bold_otol_tree(asd)
FixNegBrLen(pla, method="zero")
plot(pla)
ape::axisPhylo()
plot(x1)
x1 <- FixNegBrLen(pla, method="zero")
plot(x1)
ape::axisPhylo()
x2 <- FixNegBrLen(pla, method="bladj")
plot(x2)#
ape::axisPhylo()
tree <- pla
paste("n", seq(tree$Nnode), sep="")
treenl <- paste("n", seq(tree$Nnode), sep="")
tree$node.label <- treenl
treebt <- ape::branching.times(tree)
pos.tree <- ProcessPhy(tree)
plot(pos.tree)
nodelabels(ape::branching.times(pos.tree))
index <- which(pos.tree$edge.length<0)
index
ape::branching.times(pos.tree)
pos.tree$edge.length
treenl
tree$node.label
treebt <- ape::branching.times(tree)
cnode <- tree$edge[index,2]
cnode
tobladj <- cnode-tree$Nnode-1
tobladj
tree$Nnode
nn <- treenl[-tobladj]
na <- treebt[-tobladj]
nn
na
pos.tree <- GetBladjTree(nodenames = nn, nodeages = na, tree = tree, treeformat = "phylo")
plot(pos.tree)
nodelabels(ape::branching.times(pos.tree))
nodelabels(nn)
na
treebt
plot(pos.tree)
nodelabels(ape::branching.times(pos.tree))
nodelabels()
ls(pos.tree)
nodelabels
prop.part(pos.tree)
plot(pos.tree)
nodelabels(nn)
nn
nodelabels(treenl)
cnode
tree$Nnode-1
tobladj
cnode-(tree$Nnode-1)
tree$Nnode
cnode-(tree$Nnode-1)
tobladj <- cnode-tree$Nnode+1 # or, -length(tree$tip.label)
treenl[-tobladj]
nn <- treenl[-tobladj]
na <- treebt[-tobladj]
na
pos.tree <- GetBladjTree(nodenames = nn, nodeages = na, tree = tree, treeformat = "phylo")
plot(pos.tree)
nodelabels(treenl)
nodelabels(ape::branching.times(pos.tree))
plot(pla)
ape::axisPhylo()
nodelabels(ape::branching.times(pla))
warning("No", marker, "sequences found for", taxa.to.drop.print, "...", "\n", "\t", "Taxa dropped from tree.")
ProcessPhy <- function(input, verbose=FALSE){#
  	if(class(input) == "multiPhylo") stop("Only one phylogeny can be processed at a time.")#
	if(class(input) == "phylo") {#
		input <- ape::write.tree(input)#
	}#
 	input <- gsub("\\+"," ",input)#
  	input <- stringr::str_trim(input, side = "both")#
  	phy.new.in <- NA#
   	# if(length(input) == 1) {#
    	# if(showSummary)cat("\t", "Input is length 1.", "\n")#
	  	if(any(grepl("\\(.*\\).*;", input))) { #our test for newick#
	  		if(length(input)>1) stop("Only one phylogeny can be processed at a time.")#
	    	phy.new.in <- ape::collapse.singles(phytools::read.newick(text=gsub(" ", "_", input)))#
	    	if(verbose) {cat("\t", "Input is a phylogeny and it is correcly formatted.", "\n")}#
	  	} else {#
	  		if(verbose) {("Input is not a phylogeny.")} #not a warning nor stop, 'cause it is not a requirement for input to be a phylogeny at this step#
	  	}#
  	# }#
	return(phy.new.in)#
}
new <- "(((((Pterois miles,Pterois volitans)Pteroinae)Teleostei)Chordata,Lymnaea))Metazoa;"#
	phy <- ape::read.tree(text="((Zea mays,Oryza sativa),((Arabidopsis thaliana,(Glycine max,Medicago sativa)),Solanum lycopersicum)Pentapetalae);")#
	notnew <- "a,b;"
expect_error(ProcessPhy(c(new, new)), verbose=TRUE) #trying to process two phylogenies will give an error
librray(test_that)
library(test_that)
library(testthat)
expect_error(ProcessPhy(c(new, new)), verbose=TRUE) #trying to process two phylogenies will give an error
expect_error(ProcessPhy(c(phy, phy)), verbose=TRUE) #trying to process two phylogenies will give an error
expect_output(x <- ProcessPhy(new, verbose=TRUE)) # when verbose=TRUE it will give a printed message
expect_output(x <- ProcessPhy(phy, verbose=TRUE)) # idem
expect_output(x <- ProcessPhy(notnew, verbose=TRUE)) # idem
ProcessPhy <- function(input, verbose=FALSE){#
  	if(class(input) == "multiPhylo") stop("Only one phylogeny can be processed at a time.")#
	if(class(input) == "phylo") {#
		input <- ape::write.tree(input)#
	}#
 	input <- gsub("\\+"," ",input)#
  	input <- stringr::str_trim(input, side = "both")#
  	phy.new.in <- NA#
   	# if(length(input) == 1) {#
    	# if(showSummary)cat("\t", "Input is length 1.", "\n")#
	  	if(any(grepl("\\(.*\\).*;", input))) { #our test for newick#
	  		if(length(input)>1) stop("Only one phylogeny can be processed at a time.")#
	    	phy.new.in <- ape::collapse.singles(phytools::read.newick(text=gsub(" ", "_", input)))#
	    	if(verbose) {cat("\t", "Input is a phylogeny and it is correcly formatted.", "\n")}#
	  	} else {#
	  		if(verbose) {cat("Input is not a phylogeny.")} #not a warning nor stop, 'cause it is not a requirement for input to be a phylogeny at this step#
	  	}#
  	# }#
	return(phy.new.in)#
}
expect_output(x <- ProcessPhy(notnew, verbose=TRUE)) # idem
devtools::install_github("phylotastic/datelife")#
library(datelife)#
library(ape)#
library(geiger)#
library(testthat)#
library(microbenchmark)
load(file="seeds.RData")
ls()
setwd("~/Google Drive/datelife/runtime_tests")
load(file="seeds.RData")
ls()
seeds
x <- vector(mode="list")
x
i <- 10
load(file="aves.spp.RData")
aves.spp$cleaned.names
for(j in 1:100)#
		x <- c(x, list(sample(aves.spp$cleaned.names, i))#
	}
x <- vector(mode="list")
for(j in 1:100)#
		x <- c(x, list(sample(aves.spp$cleaned.names, i)))#
	}
for(j in 1:100){#
		x <- c(x, list(sample(aves.spp$cleaned.names, i)))#
	}
length(x)
x <- vector(mode="list")#
	for(j in 1:100){#
		x <- c(x, list(sample(aves.spp$cleaned.names, i)))#
	}
length(x)
x
xname <- paste0("random_sample_",i, "_aves_spp")
xname
assign(xname, x)
setwd("~/Google Drive/datelife/runtime_tests/name_samples")
save(list=xname, file=paste0(xname,".RData"))
i <- 5000
paste0("random_sample_",i, "_aves_spp")
i <- 10
i <- 5000
xname <- paste0("random_sample_",i, "_aves_spp")
setwd("~/Google Drive/datelife/runtime_tests/name_samples")
load(file=paste0(xname,".RData"))
ls()
i <- 100
xname <- paste0("random_sample_",i, "_aves_spp")
load(file=paste0(xname,".RData"))
y <- microbenchmark(get_datelife_result(input=get(xname[[i]]), process_input=TRUE), times=1L)
y <- microbenchmark(get_datelife_result(input=get(xname[[1]]), process_input=TRUE), times=1L)
y
y <- rbind(y, microbenchmark(get_datelife_result(input=get(xname[[j]]), process_input=TRUE), times=1L))
j <- 2
y <- rbind(y, microbenchmark(get_datelife_result(input=get(xname[[j]]), process_input=TRUE), times=1L))
j
xname[[j]]
get(xname)[[j]]
y <- rbind(y, microbenchmark(get_datelife_result(input=get(xname)[[j]], process_input=TRUE), times=1L))
y
y <- microbenchmark(get_datelife_result(input=get(xname[[1]]), process_input=TRUE), times=1L)  # input must be processed :)#
	for(j in 2:100){#
		yy <- microbenchmark(get_datelife_result(input=get(xname)[[j]], process_input=TRUE), times=1L)#
		levels(yy$expr)[1] <- paste0(i, " names")#
		y <- rbind(y, yy)#
	}
y
ggplot2::autoplot(y)
paste0("gfr_runtime_", i,"aves_spp_2018.01.10")
xnameobj <- paste0("2018.01.10_gfr_runtime_", i,"_aves_spp")
assign(xnameobj, y)
ls()
2018.01.10_gfr_runtime_100_aves_spp
xnameobj <- paste0("gfr_runtime_2018.01.10_", i,"_aves_spp")
assign(xnameobj, y)
ls()
gfr_runtime_2018.01.10_100_aves_spp
load("/Users/luna/Google Drive/datelife/runtime_tests/gfr_runtime/gfr_runtime_2018.01.10_10_aves_spp.RData")
ls()
gfr_runtime_2018.01.10_10_aves_spp
