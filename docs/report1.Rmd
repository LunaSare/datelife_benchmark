---
title: "datelife R Package Reports"
date: "`r format(Sys.time(), '%d %B %Y')`"
author: Luna L. Sanchez Reyes
output: pdf_document
fontsize: 12pts
textalign: left
geometry: margin = 1in
---
```{r setup, include = FALSE, warnings = FALSE, message = FALSE}
# reqins_pkg("microbenchmark") it is not working, getting error:
# Loading required package: pkg
# there is no package called ‘pkg’Error in install.packages : Updating loaded packages
# reqins_pkg("datelife")
loadd(ninput)
loadd(ninput2)
loadd(aves.spp)
loadd(seeds)
loadd(aves400.1.gfr.runtime_2017.12.28)
loadd(aves.all.gfr.runtime_2017.12.29)
loadd(aves.all.gfr.runtime_2018.01.12)
loadd(res28)
loadd(res29)
loadd(res01)
loadd(res04)
x <- require(microbenchmark)
if(!x){
  install.packages("microbenchmark")
}
x <- require(ggplot2)
if(!x){
  install.packages("ggplot2")
}
```
# Benchmarking Functions to Get Source Data

You'll need `datelife` and `microbenchmark` packages.
```{r eval = FALSE}
install.packages("microbenchmark")
install.packages("datelife")
library(microbenchmark)
library(datelife)
```
Then, we generate a vector of seeds to use befire each test to be able to reproduce the results afterwards:

```{r eval = FALSE}
set.seed(10)
seeds <- runif(100, 1, 1e9) 
# set.seed only accepts numbers up to 9 integers-ish:
# set.seed(2140000000)
# works with numbers <=2.14e+09
save(seeds, file="data/1_datasource/1_name_samples/seeds.RData")
```

## I. Function to search input taxa across a chronogram database

The `datelife` function that performs the chronogram searches is called `datelife_search` (previously called `get_filtered_results`)
To benchmark this function, we used species names of birds (any species within the Aves class) as input. Running time of the function was tested with a different number of input taxa: `r paste0(ninput, collapse = ", ")`
and up to all named bird species in Open Tree Taxonomy (OTT).
To do this, first we obtained all named bird species from OTT with the `make_datelife_query` function:

```{r eval = FALSE}
install.packages("datelife")
library(datelife)
aves.spp <- make_datelife_query(input="Aves", sppfromtaxon=TRUE) # 12750 spp names
save("aves.spp", file="data/1_datasource/1_name_samples/aves.spp.RData")
```

```{r eval = TRUE}
names(aves.spp)
length(aves.spp$cleaned.names)
```
So, there are `r length(aves.spp$cleaned.names)` named bird species in the OTT. Then, we generated a character vector of randomly sampled bird names for each input size. We saved these independently to ensure reproducibility:
```{r eval = FALSE}
ninput <- c(10, 100, 200, 300, 400, 500, 700, 1000, 1500, 2000, 3000, 5000, 7000, 
            8000, 9000, 10000)
for (i in ninput){
	set.seed(seeds[1])
	x <- sample(aves.spp$cleaned.names, i)
	xname <- paste0("spp",i)
	assign(xname, x)
	save(list=xname, file=paste0(xname,".RData"))
}
```

This was my first time using `microbenchmark` to profile running time of functions, so I did a little test first, using 400 bird names drawn at random from `aves.spp$cleaned.names` vector, just to look at the structure of the output and all:
```{r eval = FALSE}
set.seed(seeds[1])
spp400.1 <- sample(aves.spp$cleaned.names, 400)
aves400.1.gfr.runtime_2017.12.28 <- microbenchmark(get_datelife_result(input=spp400.1),
                                                   times=100L)
save(aves400.1.gfr.runtime_2017.12.28, file =
       "data/1_datasource/2_tests/1_same_spp_names/aves400.1.gfr.runtime_2017.12.28.RData")
```

```{r eval = TRUE, warning=FALSE, message = FALSE, fig.height = 3, fig.width = 6, fig.align = "center", fig.cap = "First try with `microbenchmark` function"}
aves400.1.gfr.runtime_2017.12.28
names(aves400.1.gfr.runtime_2017.12.28)
class(aves400.1.gfr.runtime_2017.12.28)
length(aves400.1.gfr.runtime_2017.12.28)
binded <- rbind(aves400.1.gfr.runtime_2017.12.28, aves400.1.gfr.runtime_2017.12.28)
# res <- rbind(thraupidae.ed.runtime_2017.12.28, thraupidae.ed.runtime_2017.12.28)
binded
class(binded)
length(binded)
microbenchmark:::autoplot.microbenchmark(binded)
```
Confident of understanding the structure of a microbenchmark output, we continued to start with the formal benchmarking tests.

Up to 1k names, we ran `microbenchmark` on the same R console and saved everything at the end with a loop:
```{r eval = FALSE}
aves10.1.gfr.runtime_2017.12.28 <- microbenchmark(get_datelife_result(input=spp10),
                                                  times=100L)
aves100.1.gfr.runtime_2017.12.28 <- microbenchmark(get_datelife_result(input=spp100),
                                                   times=100L)
aves200.1.gfr.runtime_2017.12.28 <- microbenchmark(get_datelife_result(input=spp200),
                                                   times=100L)
aves300.1.gfr.runtime_2017.12.28 <- microbenchmark(get_datelife_result(input=spp300),
                                                   times=100L)
aves400.1.gfr.runtime_2017.12.28 <- microbenchmark(get_datelife_result(input=spp400),
                                                   times=100L)
aves500.1.gfr.runtime_2017.12.28 <- microbenchmark(get_datelife_result(input=spp500),
                                                   times=100L)
aves700.1.gfr.runtime_2017.12.28 <- microbenchmark(get_datelife_result(input=spp700),
                                                   times=100L)
aves1000.1.gfr.runtime_2017.12.28 <- microbenchmark(get_datelife_result(input=spp1000),
                                                    times=100L)
for(i in c(10,100,200,300,400,500,700,1000)){
	xname <- paste0("data/1_datasource/2_tests/1_same_spp_names/aves", i,
	                ".1.gfr.runtime_2017.12.28")
	save(list=xname, file=paste0(xname, ".RData"))
}
```
We ran each of the following in a different R console process and saved the results independently at the end of each run:
```{r eval = FALSE}
aves1500.1.gfr.runtime_2017.12.28 <- microbenchmark(get_datelife_result(input=spp1500),
                                                    times=100L)
save(aves1500.1.gfr.runtime_2017.12.28, file =
    "data/1_datasource/2_tests/1_same_spp_names/aves1500.1.gfr.runtime_2017.12.28.RData")
aves2000.1.gfr.runtime_2017.12.28 <- microbenchmark(get_datelife_result(input=spp2000),
                                                    times=100L)
save(aves2000.1.gfr.runtime_2017.12.28, file =
    "data/1_datasource/2_tests/1_same_spp_names/aves2000.1.gfr.runtime_2017.12.28.RData")
aves3000.1.gfr.runtime_2017.12.28 <- microbenchmark(get_datelife_result(input=spp3000),
                                                    times=100L)
save(aves3000.1.gfr.runtime_2017.12.28, file =
    "data/1_datasource/2_tests/1_same_spp_names/aves3000.1.gfr.runtime_2017.12.28.RData")
aves5000.1.gfr.runtime_2017.12.28 <- microbenchmark(get_datelife_result(input=spp5000),
                                                    times=100L)
save(aves5000.1.gfr.runtime_2017.12.28, file =
    "data/1_datasource/2_tests/1_same_spp_names/aves5000.1.gfr.runtime_2017.12.28.RData")
aves7000.1.gfr.runtime_2017.12.28 <- microbenchmark(get_datelife_result(input=spp7000),
                                                    times=100L)
save(aves7000.1.gfr.runtime_2017.12.28, file =
    "data/1_datasource/2_tests/1_same_spp_names/aves7000.1.gfr.runtime_2017.12.28.RData")
aves8000.1.gfr.runtime_2017.12.28 <- microbenchmark(get_datelife_result(input=spp8000),
                                                    times=100L)
save(aves8000.1.gfr.runtime_2017.12.28, file =
    "data/1_datasource/2_tests/1_same_spp_names/aves8000.1.gfr.runtime_2017.12.28.RData")
aves9000.1.gfr.runtime_2017.12.28 <- microbenchmark(get_datelife_result(input=spp9000),
                                                    times=100L)
save(aves9000.1.gfr.runtime_2017.12.28, file =
    "data/1_datasource/2_tests/1_same_spp_names/aves9000.1.gfr.runtime_2017.12.28.RData")
aves10000.1.gfr.runtime_2017.12.28 <- microbenchmark(get_datelife_result(input=spp10000),
                                                     times=100L)
save(aves10000.1.gfr.runtime_2017.12.28, file =
    "data/1_datasource/2_tests/1_same_spp_names/aves10000.1.gfr.runtime_2017.12.28.RData")
aves.all.gfr.runtime_2017.12.29 <- microbenchmark(get_datelife_result(
  input=aves.spp$cleaned.names), times=100L)
save(aves.all.gfr.runtime_2017.12.29, file = 
       "data/1_datasource/2_tests/0_all_names/aves.all.gfr.runtime_2017.12.29.RData")
```

To plot the results, we loaded each data set into the same R console, `rbind`ed them and `autoplot` them:
```{r eval = FALSE}
for(i in ninput){
	xname <- paste0("aves",i,".1.gfr.runtime_2017.12.28")
	x <- paste0(xname, ".RData")
	load(x)
	res <- rbind(res, get(xname))
}
res <- rbind(res, aves.all.gfr.runtime_2017.12.29)
microbenchmark:::autoplot.microbenchmark(res)
```

```{r eval = TRUE, echo = FALSE, message= FALSE, warning= FALSE, fig.cap= "Tests run simultaneously for input size > 1000 names.", fig.height = 3, fig.width = 6, fig.align = "center"}
res28 <- rbind(res28, aves.all.gfr.runtime_2017.12.29)
microbenchmark:::autoplot.microbenchmark(res28)
```

Results look weirdly flat. This might be because we ran some of the tests simultaneously on the same computer. So we ran the whole thing again, one test after another (not running tests at the same time in the computer):
```{r eval = FALSE}
ninput <- c(10, 100, 200, 300, 400, 500, 700, 1000, 1500, 2000, 3000, 5000, 7000, 
            8000, 9000, 10000)
for(i in ninput){
	xname <- paste0("spp",i)
	load(paste0(xname,".RData"))
	x <- microbenchmark(get_datelife_result(input=get(xname), process_input=TRUE), 
	                    times=100L) # input must be processed :)
	# y <- levels(x$expr)
	# levels(x$expr)[levels(x$expr==y)] <- paste0(i, " names")
	levels(x$expr)[1] <- paste0(i, " names")
	xnameobj <- paste0("aves",i,".1.gfr.runtime_2017.12.29")
	assign(xnameobj, x)
	save(list=xnameobj, file=paste0("data/1_datasource/2_tests/1_same_spp_names/",
	                                xnameobj,".RData"))
	rm(list=xnameobj)
}
```
And we `rbind`ed the outputs again in a new console and used `autoplot` to visualize results:
```{r eval = FALSE}
res <- c()
for(i in ninput){
	xname <- paste0("aves",i,".1.gfr.runtime_2017.12.29")
	res <- rbind(res, get(xname))
}
res <- rbind(res, aves.all.gfr.runtime_2017.12.29)
microbenchmark:::autoplot.microbenchmark(res)
```
```{r eval = TRUE, echo = FALSE, warning=FALSE, message = FALSE, fig.cap= "Tests run consecutively on the same machine."}
res29 <- rbind(res29, aves.all.gfr.runtime_2017.12.29)
microbenchmark:::autoplot.microbenchmark(res29)
```

This is good, but we want a prettier plot:
```{r eval = TRUE, message = FALSE}
autoplot.gfr <- function (object, ..., log = TRUE, y_max = 1.05 * max(object$time)) {
    y_min <- 0
    object$Time <- microbenchmark:::convert_to_unit(object$time, "t") 
    #changing the name of the element itself is the easiest way to make it appear as axis label
    # object$'Query Length' <- object$expr #changing for a name with spaces won't work...
    plt <- ggplot2::ggplot(object, ggplot2::aes_string(x = "expr", y = "Time"))
    plt <- plt + coord_cartesian(ylim = c(y_min, y_max))
    plt <- plt + stat_ydensity()
    # plt <- plt + xlim(levels(object$expr)[length(levels(object$expr)):1])
    plt <- plt + scale_x_discrete(name = "")
    plt <- plt + theme(axis.text.x = element_text(angle=270))
    plt <- plt + theme(axis.text.y = element_text(angle=315))
    plt <- if (log) {
        # plt + scale_y_log10(name = sprintf("", attr(object$ntime, "unit"))) 
          # this does not work...
        # plt + scale_y_log10(name = sprintf("Time", attr(object$ntime, "unit"))) 
          # this does not work...
        # plt + scale_y_log10(name = "Seconds") # this does not work either...
		plt + scale_y_log10(breaks=c(1e+03, 1e+035, 1e+04, 1e+045, 1e+05),
		                    labels=c("1e+03"="1s", "1e+035"="", "1e+04"="10s", 
		                             "1e+045"="", "1e+05"="100s"), position="top")
    }
    else {
        plt + scale_y_continuous(name = sprintf("Time [%s]", attr(object$ntime, "unit")))
    }
    plt <- plt + ggplot2::coord_flip() # these exchanges the axis
    # if I inactivate this, I get the following Warning message:
# Transformation introduced infinite values in continuous y-axis 
# Need to figure out how to transform time so I won't get this warning
    plt
}
```
```{r eval = TRUE, echo = FALSE}
res <- res29
```
```{r eval = TRUE, message = FALSE}
res
autoplot.gfr(res)
autoplot.gfr(res, log=FALSE)

```
Results look good at this point. But we wanna have the time on the x axis.
```{r eval = TRUE, message = FALSE}
res.plt <- autoplot.gfr(res)
res.plt + scale_y_log10(name = "Seconds") # this does not work
res.plt + scale_y_log10(labels =c("1e+03"="1s", "1e+035"="", "1e+04"="10s", 
                                  "1e+045"="", "1e+05"="100s")) 
# this works to change the labels, but I need to specify breaks to be sure it works appropriately
labels(res.plt)
res.plt$labels
str(res.plt)
```


Now, for each size of input names, we sampled 100 different vector of names: 

```{r, echo= TRUE, eval = FALSE}
ninput <- c(10, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1500, 2000, 3000,
            4000, 5000, 6000, 7000, 8000, 9000, 10000)

for(i in ninput){
	x <- vector(mode="list")
	for(j in 1:100){
		x <- c(x, list(sample(aves.spp$cleaned.names, i)))
	}
	xname <- paste0("random_sample_",i, "_aves_spp")
	assign(xname, x)
	save(list=xname, file=paste0("data/1_datasource/1_name_samples/", xname,".RData"))
}
```
Now we noticed a slowdown on the first run, probably because cache is loading for the very first time. So we launched a first run that wass not recorded, to make sure everything is loaded when we start the actual tests:
```{r eval = FALSE}
asd <- "((Zea mays,Oryza sativa),((Arabidopsis thaliana,(Glycine max,Medicago sativa)),
        Solanum lycopersicum)Pentapetalae);"
get_datelife_result(input=asd, process_input=TRUE)
```
Now we can run the tests consecutively again:
```{r eval = FALSE}
for(i in ninput){
	xname <- paste0("random_sample_",i, "_aves_spp")
	setwd("data/1_datasource/1_name_samples")
	load(file=paste0(xname,".RData"))
	y <- microbenchmark(get_datelife_result(input=get(xname)[[1]], 
	                                        process_input = TRUE),times=1L)  
	# input should be processed? we are then testing two functions in here...
	levels(y$expr)[1] <- paste0(i, " names")
	for(j in 2:100){
		yy <- microbenchmark(get_datelife_result(input=get(xname)[[j]], process_input=TRUE), 
		                     times=1L)
		levels(yy$expr)[1] <- paste0(i, " names")
		y <- rbind(y, yy)
	}	
	rm(list=xname)
	xnameobj <- paste0("gfr_runtime_2018.01.10_", i,"_aves_spp")
	assign(xnameobj, y)
	save(list=xnameobj, file=paste0("data/1_datasource/2_tests/2_random_spp_names/1_gfr", 
	                                xnameobj,".RData"))
	rm(list=xnameobj)
}
aves.all.gfr.runtime_2018.01.12 <- microbenchmark(get_datelife_result(input =
                                  aves.spp$cleaned.names), times=100L)
levels(aves.all.gfr.runtime_2018.01.12$expr)[1] <- "12750"
save(aves.all.gfr.runtime_2018.01.12,
     file="data/1_datasource/2_tests/0_all_names/aves.all.gfr.runtime_2018.01.12.RData")
```
Now, load and `rbind` the stuff if you opened a new session:
```{r eval = FALSE}
res01 <- c()
for(i in ninput){
	xname <- paste0("gfr_runtime_2018.01.10_",i,"_aves_spp")
	x <- paste0("data/1_datasource/2_tests/2_random_spp_names/1_gfr", xname, ".RData")
	load(x)
	res01 <- rbind(res01, get(xname))
}
load(file="data/1_datasource/2_tests/0_all_names/aves.all.gfr.runtime_2018.01.12.RData")
```
```{r eval= TRUE}
res01 <- rbind(res01, aves.all.gfr.runtime_2018.01.12)
```

And plot again

We need to change xlabels. One way to do this is to change the levels of the `expr` element:
```{r eval= TRUE}
levels(res01$expr) <- as.character(c(ninput, "all Aves (12750)"))
```
Then set the time limits:
```{r eval= TRUE}
y_min <- 200
y_max <- 1e+5
res01$Time <- microbenchmark:::convert_to_unit(res$time, "t") 
#changing the name of the element itself is the easiest way to make it appear as axis label
# object$'Query Length' <- object$expr 
# note that if you try to use spaces here it won't work...
plt <- ggplot2::ggplot(res01, ggplot2::aes_string(x = "expr", y = "Time"))
plt <- plt + ggplot2::coord_cartesian(ylim = c(y_min, y_max))
plt <- plt + ggplot2::stat_ydensity()
plt <- plt + ggplot2::scale_x_discrete(name = "Query Length (log10)",
       labels=c("10 names" = "1",
                "100 names" = expression(10^2),
                "200 names" = expression(2*"x"*10^2),
                "300 names" = expression(3*"x"*10^2),
                "400 names" = expression(4*"x"*10^2),
                "500 names" = expression(5*"x"*10^2),
                "700 names" = expression(7*"x"*10^2),
                "1000 names" = expression(10^3),
                "1500 names" = expression(1.5*"x"*10^3),
                "2000 names" = expression(2*"x"*10^3),
                "3000 names" = expression(3*"x"*10^3),
                "4000 names" = expression(4*"x"*10^3),
                "5000 names" = expression(5*"x"*10^3),
                "6000 names" = expression(6*"x"*10^3),
                "7000 names" = expression(7*"x"*10^3),
                "8000 names" = expression(8*"x"*10^3),
                "9000 names" = expression(9*"x"*10^3),
                "10000 names" = expression(10^4),
                "12750" = expression(1.275*"x"*10^4)
       ))
plt <- plt + ggplot2::theme(axis.text.x = ggplot2::element_text(angle=45, hjust=1))
plt <- plt + ggplot2::theme(axis.text.y = ggplot2::element_text(angle=0))
plt <- plt + ggplot2::scale_y_log10(name="Time (seconds)", breaks=c(1e+03, 1e+04, 3e+04, 1e+05), 
        labels=c("1e+03"="1 s", "1e+04"="10 s", "3e+04"="30 s", "1e+05"="100 s"), 
            position="left",
            sec.axis = ggplot2::sec_axis(~ . *1, name="Time (minutes)", 
            breaks=c(6e+03, 3e+04, 6e+04, 9e+04), 
            labels=c("6e+03"="0.1 min", "3e+04"="0.5 min", "6e+04"="1 min", "9e+04"="1.5 min")))
plt
```
I didn't like the labels, let's try these ones:
```{r eval = TRUE, message = FALSE}
plt <- plt + ggplot2::scale_x_discrete(name = "Query Length", 
       labels=c("10 names" = "10", 
                "100 names" = "100", 
                "200 names" = "200", 
                "300 names" = "300", 
                "400 names" = "400", 
                "500 names" = "500", 
                "700 names" = "700", 
                "1000 names" = expression(1~0*0*0),
                "1500 names" = expression(1~500), 
                "2000 names" = expression(2~0*0*0), 
                "3000 names" = expression(3~0*0*0), 
                "4000 names" = expression(4~0*0*0), 
                "5000 names" = expression(5~0*0*0), 
                "6000 names" = expression(6~0*0*0), 
                "7000 names" = expression(7~0*0*0), 
                "8000 names" = expression(8~0*0*0), 
                "9000 names" = expression(9~0*0*0), 
                "10000 names" = expression(10~0*0*0), 
                "12750" = expression(12~750)))
plt
```

